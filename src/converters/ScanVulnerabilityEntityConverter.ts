import {
  TENABLE_VULNERABILITY_ENTITY_CLASS,
  TENABLE_VULNERABILITY_ENTITY_TYPE,
  TenableVulnerabilityEntity,
} from "../jupiterone/entities";
import { Dictionary, ScanVulnerability } from "../tenable/types";
import { generateEntityKey } from "../utils/generateKey";

/**
 * Produces a set of unique vulnerability entities, which may each be referenced
 * a number of times across a number of scan hosts.
 *
 * @param vulnerabilities a Dictionary of hostname -> ScanVulnerabilities[]
 */
export function createVulnerabilityEntities(
  vulnerabilities: Dictionary<ScanVulnerability[]>,
): TenableVulnerabilityEntity[] {
  const seenPluginIds = new Set();
  return Object.values(vulnerabilities).reduce(
    (acc: TenableVulnerabilityEntity[], data: ScanVulnerability[]) => {
      const vulnEntities = data.reduce(
        (entities: TenableVulnerabilityEntity[], vuln) => {
          if (!seenPluginIds.has(vuln.plugin_id)) {
            entities.push(createTenableVulnerabilityEntity(vuln));
            seenPluginIds.add(vuln.plugin_id);
          }
          return entities;
        },
        [],
      );
      return [...acc, ...vulnEntities];
    },
    [],
  );
}

export function createTenableVulnerabilityEntity(
  vulnerability: ScanVulnerability,
): TenableVulnerabilityEntity {
  return {
    _key: tenableVulnerablilityEntityKey(vulnerability),
    _type: TENABLE_VULNERABILITY_ENTITY_TYPE,
    _class: TENABLE_VULNERABILITY_ENTITY_CLASS,
    pluginId: vulnerability.plugin_id,
    pluginFamily: vulnerability.plugin_family,
    pluginName: vulnerability.plugin_name,
    severity: vulnerability.severity,
  };
}

export function tenableVulnerablilityEntityKey(vulnerability: {
  plugin_id: number;
}): string {
  return generateEntityKey(
    TENABLE_VULNERABILITY_ENTITY_TYPE,
    vulnerability.plugin_id,
  );
}
